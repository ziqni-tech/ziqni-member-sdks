/* tslint:disable */
/* eslint-disable */
/**
 * Ziqni Gamification Cloud API
 * This is the gamification cloud for Ziqni
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import {
    RuleRoutine,
    RuleRoutineFromJSON,
    RuleRoutineFromJSONTyped,
    RuleRoutineToJSON,
} from './';

/**
 * A conditional expressions is an element that declares either a rule expression, condition or routine to be evaluated or executed
 * @export
 * @interface RuleExpression
 */
export interface RuleExpression {
    /**
     * condition or expression or routine
     * @type {string}
     * @memberof RuleExpression
     */
    type: string;
    /**
     * All expressions in the condition must either evaluate to TRUE or FALSE if set to TRUE
     * @type {boolean}
     * @memberof RuleExpression
     */
    mustMatchAll?: boolean;
    /**
     * All the expressions of this condition must either evaluate to TRUE or FALSE
     * @type {boolean}
     * @memberof RuleExpression
     */
    mustEvaluateTo?: boolean;
    /**
     * The scope of the operand used in the expression
     * @type {string}
     * @memberof RuleExpression
     */
    scope?: string;
    /**
     * The order the rules have to be executed in.
     * @type {string}
     * @memberof RuleExpression
     */
    operand?: string;
    /**
     * [ *.* ] or [ .* ] or [ == ] or [ > ] or [ >= ] or [ <=]  or [ < ] or [ <> ]
     * @type {string}
     * @memberof RuleExpression
     */
    operator?: string;
    /**
     * The value associated with the expression
     * @type {string}
     * @memberof RuleExpression
     */
    value?: string;
    /**
     * 
     * @type {Array<RuleExpression>}
     * @memberof RuleExpression
     */
    rules?: Array<RuleExpression>;
    /**
     * 
     * @type {Array<RuleRoutine>}
     * @memberof RuleExpression
     */
    then?: Array<RuleRoutine>;
    /**
     * 
     * @type {number}
     * @memberof RuleExpression
     */
    lineNumber?: number;
}

export function RuleExpressionFromJSON(json: any): RuleExpression {
    return RuleExpressionFromJSONTyped(json, false);
}

export function RuleExpressionFromJSONTyped(json: any, ignoreDiscriminator: boolean): RuleExpression {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'type': json['type'],
        'mustMatchAll': !exists(json, 'mustMatchAll') ? undefined : json['mustMatchAll'],
        'mustEvaluateTo': !exists(json, 'mustEvaluateTo') ? undefined : json['mustEvaluateTo'],
        'scope': !exists(json, 'scope') ? undefined : json['scope'],
        'operand': !exists(json, 'operand') ? undefined : json['operand'],
        'operator': !exists(json, 'operator') ? undefined : json['operator'],
        'value': !exists(json, 'value') ? undefined : json['value'],
        'rules': !exists(json, 'rules') ? undefined : ((json['rules'] as Array<any>).map(RuleExpressionFromJSON)),
        'then': !exists(json, 'then') ? undefined : ((json['then'] as Array<any>).map(RuleRoutineFromJSON)),
        'lineNumber': !exists(json, 'lineNumber') ? undefined : json['lineNumber'],
    };
}

export function RuleExpressionToJSON(value?: RuleExpression | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'type': value.type,
        'mustMatchAll': value.mustMatchAll,
        'mustEvaluateTo': value.mustEvaluateTo,
        'scope': value.scope,
        'operand': value.operand,
        'operator': value.operator,
        'value': value.value,
        'rules': value.rules === undefined ? undefined : ((value.rules as Array<any>).map(RuleExpressionToJSON)),
        'then': value.then === undefined ? undefined : ((value.then as Array<any>).map(RuleRoutineToJSON)),
        'lineNumber': value.lineNumber,
    };
}

