/*
ZIQNI Member API

The ZIQNI Member-API is the primary resource used to build services and widgets for your members [customers, players, patients, etc]. The service is Stomp websokets with SOCK.js even though the system is decribed using OpenApi schema for convenience.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// EntityType Entity the item is associated to.
type EntityType string

// List of EntityType
const (
	MEMBER EntityType = "Member"
	PRODUCT EntityType = "Product"
	ACHIEVEMENT EntityType = "Achievement"
	REPOSITORY EntityType = "Repository"
	FILE_OBJECT EntityType = "FileObject"
	LANGUAGE EntityType = "Language"
	MEMBER_MESSAGE EntityType = "MemberMessage"
	REWARD EntityType = "Reward"
	MEMBER_AWARD EntityType = "MemberAward"
	AWARD EntityType = "Award"
	MESSAGE EntityType = "Message"
	REWARD_TYPE EntityType = "RewardType"
	ACTION_TYPE EntityType = "ActionType"
	UNIT_OF_MEASURE EntityType = "UnitOfMeasure"
	COMPETITION EntityType = "Competition"
	CONTEST EntityType = "Contest"
	SQS_CONNECTION EntityType = "SqsConnection"
	KAFKA_CONNECTION EntityType = "KafkaConnection"
	RABBIT_MQ_CONNECTION EntityType = "RabbitMqConnection"
	EVENTS EntityType = "Events"
	WEBHOOK EntityType = "Webhook"
	ATTACHMENT EntityType = "Attachment"
	RULE_SET EntityType = "RuleSet"
)

// All allowed values of EntityType enum
var AllowedEntityTypeEnumValues = []EntityType{
	"Member",
	"Product",
	"Achievement",
	"Repository",
	"FileObject",
	"Language",
	"MemberMessage",
	"Reward",
	"MemberAward",
	"Award",
	"Message",
	"RewardType",
	"ActionType",
	"UnitOfMeasure",
	"Competition",
	"Contest",
	"SqsConnection",
	"KafkaConnection",
	"RabbitMqConnection",
	"Events",
	"Webhook",
	"Attachment",
	"RuleSet",
}

func (v *EntityType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := EntityType(value)
	for _, existing := range AllowedEntityTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid EntityType", value)
}

// NewEntityTypeFromValue returns a pointer to a valid EntityType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewEntityTypeFromValue(v string) (*EntityType, error) {
	ev := EntityType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for EntityType: valid values are %v", v, AllowedEntityTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v EntityType) IsValid() bool {
	for _, existing := range AllowedEntityTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to EntityType value
func (v EntityType) Ptr() *EntityType {
	return &v
}

type NullableEntityType struct {
	value *EntityType
	isSet bool
}

func (v NullableEntityType) Get() *EntityType {
	return v.value
}

func (v *NullableEntityType) Set(val *EntityType) {
	v.value = val
	v.isSet = true
}

func (v NullableEntityType) IsSet() bool {
	return v.isSet
}

func (v *NullableEntityType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableEntityType(val *EntityType) *NullableEntityType {
	return &NullableEntityType{value: val, isSet: true}
}

func (v NullableEntityType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableEntityType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

