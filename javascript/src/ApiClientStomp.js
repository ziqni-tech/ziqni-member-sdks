/**
 * Ziqni Gamification Cloud API
 * This is the gamification cloud for Ziqni
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import superagent from "superagent";
import querystring from "querystring";

if (window && window.chrome && window.chrome.app && !window.chrome.app.runtime) {
    window.chrome.app.runtime = {};
}

const StompJs = require('@stomp/stompjs');
const SockJS = require('sockjs-client');

/**
* @module ApiClient
* @version 0.0.1
*/

/**
* Manages low level client-server communications, parameter marshalling, etc. There should not be any need for an
* application to use this class directly - the *Api and model classes provide the public API for the service. The
* contents of this file should be regarded as internal but are documented for completeness.
* @alias module:ApiClient
* @class
*/
class ApiClientStomp {
    /**
     * @type StompJs.Client
     */
    client

    /**
     * The base URL against which to resolve every API call's (relative) path.
     * Overrides the default value set in spec file if present
     * @param {String} basePath
     * @param {String} sockJSPath
     */
    constructor(basePath = 'wss://member-api.ziqni.com/ws', sockJSPath = 'https://member-api.ziqni.com/ws') {
        /**
         * The base URL against which to resolve every API call's (relative) path.
         * @type {String}
         * @default https://member-api.ziqni.com
         */
        this.basePath = basePath.replace(/\/+$/, '');

        this.sockJSPath = sockJSPath;

        /**
         * The authentication methods to be included for all API calls.
         * @type {Array.<String>}
         */
        this.authentications = {
            'OAuth2': {type: 'oauth2'}
        }

        /**
         * The default HTTP headers to be included for all API calls.
         * @type {Array.<String>}
         * @default {}
         */
        this.defaultHeaders = {
            'User-Agent': 'OpenAPI-Generator/0.0.1/Javascript'
        };

        /**
         * The default HTTP timeout for all API calls.
         * @type {Number}
         * @default 60000
         */
        this.timeout = 60000;

        const _this = this;

        /*
         * Used to save and return cookies in a node.js (non-browser) setting,
         * if this.enableCookies is set to true.
         */
        if (typeof window === 'undefined') {
            this.agent = new superagent.agent();
        }

        this.publicToken = 'eyJhbGciOiJIUzI1NiJ9.eyJhcGlfa2V5X2lkIjoicXhtcXFZRUJUZVV0U0VzNEVJLWgiLCJtZW1iZXJfcmVmZXJlbmNlX2lkIjoiVGVzdF9rZXktMDYwNzg0NGYtMjU1Yy00ZDE5LTg1YTAtYzQzNmMxZDRmNTVlIiwiYWNjb3VudF9pZCI6IkY3bThkSHdCc3ctT0gzTUVvVzIzIiwic3BhY2VfbmFtZSI6ImZpcnN0LXNwYWNlIiwibmFtZSI6IlRlc3RfbmFtZS0zYWE1YzRlZS1jY2VlLTRiZWMtYjU5My1kYTdiMzAwZWU4OTAiLCJtZW1iZXJfdHlwZSI6IkluZGl2aWR1YWwiLCJtZW1iZXJfaWQiOiJ3LVVlSElJQnVwTjhDRjN6YzBoeiIsInJlc291cmNlX2FjY2VzcyI6eyJ6aXFuaS1nYXBpIjp7InJvbGVzIjpbIlB1YmxpYyIsIk1lbWJlciIsIlZpZXdBY2hpZXZlbWVudHMiLCJWaWV3QXdhcmRzIiwiQ2xhaW1Bd2FyZHMiLCJWaWV3Q29tcGV0aXRpb25zIiwiVmlld0NvbnRlc3RzIiwiVmlld0ZpbGVzIiwiVmlld01lbWJlcnMiLCJNZW1iZXJzT3B0aW4iLCJWaWV3TWVzc2FnZXMiLCJDb25uZWN0UHJveHkiLCJWaWV3UmV3YXJkcyIsIlZpZXdSdWxlcyJdfX0sInN1YiI6InctVWVISUlCdXBOOENGM3pjMGh6IiwianRpIjoiM2JkZjFhMmQtOTg1NS00NTJiLWEyZDctYTFmY2ZiNTUyMzZmIiwiaWF0IjoxNjU5MDk4Mjk3LCJleHAiOjE2NjEyNTgyOTd9.xurnAsrRccborCMqEhLYDkhpYLmvSWn9U3qP550H3fg';

        this.rpcCallBacks = new Map();
        this.sysCallBack = null;

        this.client = new StompJs.Client({
            brokerURL: this.basePath,
            connectHeaders: {
                login: 'Bearer',
                passcode: this.publicToken,
            },
            debug: function (str) {
                console.log(str);
            },
            reconnectDelay: 5000,
            heartbeatIncoming: 4000,
            heartbeatOutgoing: 4000,
        });

        this.client.webSocketFactory = function () {
            return new SockJS(_this.sockJSPath, [], {timeout: 10000});
        };
    }

    /**
     * Updates the basePath and sockJSPath for the client
     * @param {String} basePath - New WebSocket URL
     * @param {String} sockJSPath - New SockJS URL
     */
    updatePaths(basePath, sockJSPath) {
        this.basePath = basePath.replace(/\/+$/, '');
        this.sockJSPath = sockJSPath;

        // Recreate the client with new paths
        this.client = new StompJs.Client({
            brokerURL: this.basePath,
            connectHeaders: {
                login: 'Bearer',
                passcode: this.publicToken,
            },
            debug: function (str) {
                console.log(str);
            },
            reconnectDelay: 5000,
            heartbeatIncoming: 4000,
            heartbeatOutgoing: 4000,
        });

        this.client.webSocketFactory = () => {
            return new SockJS(this.sockJSPath, [], {timeout: 10000});
        };
    }

    /**
     * Returns a string representation for an actual parameter.
     * @param param The actual parameter.
     * @returns {String} The string representation of <code>param</code>.
     */
    connect = async (param) => new Promise((resolve, reject) => {
        this.client.beforeConnect =  () => {
            if (param && param.token){
                this.client.connectHeaders = {
                    login: 'Bearer',
                    passcode: param.token,
                }
            }
        };

        this.client.onConnect =  (frame) => {
            if (frame.command === 'CONNECTED') {
                const rpcCallbackSubscription = this.client.subscribe("/user/queue/rpc-results", this.handleRpcCallback);
                const sysCallbackSubscription = this.client.subscribe("/user/queue/callbacks", this.handleSysCallback);

                resolve()
            }
        };

        this.client.onStompError = (frame) => {
            console.log('Broker reported error: ' + frame.headers['message']);
            console.log('Additional details: ' + frame.body);
            resolve(frame.headers['message']);
            if (typeof this.sysCallBack === 'function') {
                this.sysCallBack(frame.headers['message'], {objectType: 'Error'})
            }
        };

        this.client.activate();
    })

    disconnect = async () => new Promise((resolve, reject) => {
        this.client.deactivate().then(() => resolve()).catch(() => reject());
    });

    uuidv4() {
        return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
          (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
        );
    }

    handleRpcCallback = (message) => {
        if (message.body) {
            const messageId = message.headers['message-id'];
            const callback = this.rpcCallBacks && this.rpcCallBacks.get(messageId);

            if(callback) {
                callback(JSON.parse(message.body));
            }
        } else {
            console.log('message with empty body', message);
        }
    };

    handleSysCallback = (message) => {
        if (message.body) {
            if (typeof this.sysCallBack === 'function') {
                this.sysCallBack(JSON.parse(message.body), message.headers)
            } else {
                console.log("SysCallBack is empty. Message: " + message.body);
            }
        } else {
            console.log('message with empty body', message);
        }
    };

    sendRpc(destination, message, callback) {
        const messageId = this.uuidv4();
        const messageHeaders = { 'message-id': messageId };

        if (this.client.connected) {
            this.client.publish({destination, headers: messageHeaders, body: JSON.stringify(message)});
        }

        this.rpcCallBacks.set(messageId, callback);
    }

    sendSys(destination, message, callback) {
        this.client.publish({destination, body: JSON.stringify(message)});
        this.sysCallBack = callback;
    }
}

/**
 * The default API Stomp client implementation.
 * @type {module:ApiClientStomp}
 */
ApiClientStomp.instance = new ApiClientStomp();

/**
 * Static method to update paths for the default instance
 * @param {String} basePath - New WebSocket URL
 * @param {String} sockJSPath - New SockJS URL
 */
ApiClientStomp.updateInstancePaths = function(basePath, sockJSPath) {
    ApiClientStomp.instance.updatePaths(basePath, sockJSPath);
};

export default ApiClientStomp;
